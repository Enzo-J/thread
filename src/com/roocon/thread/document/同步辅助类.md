1:TODO:CountDownLatch   CyclicBarrier   Semaphore各自的应用场景（例子）
2:源码分析――
CountDownLatch――共享锁（tip：这里的源码视频没有看）
#Future――提前完成任务
解析――做四菜一养胃粥，那么我们可以先下米熬粥，在粥未完成之前，分别做那四道菜，
等粥熬好了之后，再进行获取。在这里，熬粥，就是一个提前完成任务Future。
###Callable与Runnable的区别：
Runnable run方法是被线程调用的，在run方法是异步执行的，  
Callable的call方法，不是异步执行的，是由Future的run方法调用的  
Callable可以大致看成，是Runnable和result的组合体  
###ForkJoin框架――RecursiveTask
ForkJoinTask   ForkJoinPool

###同步容器和并发容器
####同步容器
Vector -> ArrayList  
HashTable -> HashMap  
当然，也有个Collections.synchronizedList()和synchronizedMap()，不常用。只是变成
同步代码块级别。
####并发容器
CopyOnWriteArrayList，有点读写分离的味道  
ConcurrectHashMap,降低锁的力度，之前我们加锁，锁的是整张表。而这里，是将一张大表分为若干张小表。所以，锁的表比较小，
性能就提升起来了。  


