#线程通信
1：线程通信的目标是使线程间的通信能够互相发送信号。这个信号可以是一个变量，而其他线程监控着这个变量，
根据这个变量进行操作。  
2：sleep不会释放锁，wait释放锁。  
3：notify方法会随机叫醒一个处于wait状态的线程，而notifyAll叫醒所有处于wait线程，争夺到时间片的线程只有一个。
这两个都会拿到锁
4：不管是释放锁（wait）还是拿到锁（notify），都是等到其上述的synchronized锁释放后才进行操作――并不是在调用了
wait或者notify之后就释放锁或者拿到锁，而是等到方法执行完成。
###wait和notify为什么要在同步代码块中――
因为wait和notify都需要锁，这个锁，可以是同步代码块中锁住的对象[synchronized(d)],所以，我们调用该对象的wait
和notify，才能起到效果。
###Condition
####Condition和wait/notify的区别
前者比后者精细，例如，notify无法准确的唤醒某个线程，而condition可以。
####Condition源码解析：
同步队列：当线程没有拿到锁，就放在同步队列中，等待抢占CPU资源的。  
等待队列：调用了await方法后，就进入等待队列。如果没有进入同步队列中并唤醒，是没有机会运行的。Condition被new
出来，都是等待队列，而wait/notify并不是，只有一个。  
借用AQS下的Node做单向链表，将新增的节点加至链表的末尾处，如果被唤醒的话，就从头部移除一个节点，该节点进入同步
队列中，开始竞争CPU资源。
####join――线程的加塞
这里面的源码――wait需要好好的分析下（wait释放的是synchronized的锁，而拿到这个锁的，是一开始的线程的）
线程终止的时候，会调用notifyAll方法，会叫醒所有wait方法。
#####tip:
java数据结构下的链表操作学习下，再回来看关于Node的源码