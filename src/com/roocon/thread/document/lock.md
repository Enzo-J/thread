#ReentrantLock:
1：所有线程共用一把锁，才能锁住同步代码块。  
2：认识：方便实现公平性；非阻塞的获取锁；能被中断的获取锁；超时获取锁
###自己通过wait/notify实现的锁
1：实现能锁  
2：实现可重入——实现思想：判断当前线程是不是之前的线程；维护一个计数器
###AQS
AQS，作为一个框架，为我们维护一个队列以及一个状态标记，队列容纳了处于等待状态的线程，并处理（移除）
处于等待状态下的线程后出现情况使得该线程丧失等待状态的线程（回顾下数据结构，双向队列）。状态标记，
很大程度是用来处理重入的情况。  
http://tool.oschina.net/apidocs/apidoc?api=jdk-zh
###公平锁与非公平锁
reecentlock的公平与非公平锁，差别就在于，公平锁多了一个队列Node判断，判断先前是否还有Node
###读写锁
####排他锁与共享锁
synchronized与recentlock，都是排他锁（一个时刻，只允许一个线程访问），而读写锁是排他锁（写锁），也是共享锁（读锁）(在同一时刻，可以多个线程同时执行)。  
读读不互斥    读写互斥     写写互斥  现实开发中，读远多于写  
####读写锁的源码分析
#####读写锁需要保存的状态
1：读锁的个数  
2：每个读锁重入的次数  
3：写锁重入的次数（int的低16位存的是写锁重入的次数）  
TODO：26需要回去重新看（主要是共享锁）
#####读写锁锁降级
锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，
如果当前线程不获取读锁而是直接释放写锁， 假设此刻另一个线程（记作线程T）
获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，
即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，
线程T才能获取写锁进行数据更新。
https://blog.csdn.net/qiuwenjie123/article/details/79950532

 