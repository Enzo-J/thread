#线程安全问题
###为什么会出现安全性问题
1：多线程环境  
2：多线程共享资源  
3：对资源进行非原子性操作（只读，就是原子性操作）value++,其实是由若干个字节码指令组成的。
###synchronized
1：synchronized加在方法上，可以这样理解——在方法上加一把锁，一次仅允许一个线程，该线程先从堆内存中获取并放进自身的
的栈空间中，再获取锁，独自进入方法去进行操作（相当于被其修饰的代码是原子性操作，且同一时刻， 被修饰的代码只有一个线程在操作），
操作完将值再刷回堆内存，再而释放锁，允许后面的线程进行竞争获取，周而复始。  
2：内置锁——Java中每个对象都可以用作同步的锁。
3：锁是互斥的  
4：synchronized放在普通方法上，内置锁就是当前类的实例，修饰静态方法，是当前的Class字节码对象（xxx.class）
锁同步代码块  
5：任何对象都可以作为锁，那么锁信息存在对象的什么地方？——存在对象头中
###偏向锁
1：每次获取锁和释放锁会浪费资源，且很多情况下竞争锁不是由多个线程而是由一个线程在使用，
所以就有了偏向锁，为一个线程访问代码块的场景提供性能。
###轻量级锁
1：同时让多个线程进入同步代码块中。
2：在栈中放置要进入同步代码块的线程，并用一个标志位标明（这样理解对不对）  
3：用上了自旋
###重量级锁
就是synchronized，当一个线程进入之后，其他线程必须排队等候。
###tip：这个应该是有相关的文章的