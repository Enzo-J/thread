#线程安全问题
###为什么会出现安全性问题
1：多线程环境  
2：多线程共享资源  
3：对资源进行非原子性操作（只读，就是原子性操作）value++,其实是由若干个字节码指令组成的。
###synchronized
1：synchronized加在方法上，可以这样理解——在方法上加一把锁，一次仅允许一个线程，该线程先从堆内存中获取并放进自身的
的栈空间中，再获取锁，独自进入方法去进行操作（相当于被其修饰的代码是原子性操作，且同一时刻， 被修饰的代码只有一个线程在操作），
操作完将值再刷回堆内存，再而释放锁，允许后面的线程进行竞争获取，周而复始。  
2：内置锁——Java中每个对象都可以用作同步的锁。
3：锁是互斥的  
4：synchronized放在普通方法上，内置锁就是当前类的实例，修饰静态方法，是当前的Class字节码对象（xxx.class）
锁同步代码块  
5：任何对象都可以作为锁，那么锁信息存在对象的什么地方？——存在对象头中
###偏向锁
1：每次获取锁和释放锁会浪费资源，且很多情况下竞争锁不是由多个线程而是由一个线程在使用，
所以就有了偏向锁，为一个线程访问代码块的场景提供性能。
###轻量级锁
1：同时让多个线程进入同步代码块中，有一个线程进入执行同步代码块内容的时候，对象头中会有相应的标记，当有另一个线程拿到锁时通过检查这个标志位，
得出不能执行代码的结论，所以该线程自旋，知道前一个线程退出，标志位回复后才能进入同步代码块中进行操作。
###重量级锁
就是synchronized，当一个线程进入之后，其他线程必须排队等候。
####tip：这个应该是有相关的文章的

###单例问题
饿汉式  
懒汉式
###锁重入
a同步代码块和b同步代码块都是被synchronized锁，且锁的是同一个对象，b同步代码块包含在a同步代码块中，这时，有个线程获取了
对象锁进入a同步代码块执行，遇到b同步代码块的时候，不用再尝试着去获取锁了，这就是锁重入。synchronized和ReentrantLock
都是重入锁
###自旋锁
当一个线程进入运行的时候，另外的线程一直在自旋等待，等待机会，直到上一个线程释放锁之后该线程获取锁进去运行
###volatile关键字
被volatile修饰的变量，在线程之间是可见的，但不保证原子性。
可见：一个线程修改了这个变量的值，另一个线程能够读到这个修改后的值。  
synchronized出了线程之间互斥外，还保证可见性。
####volatile原理：
https://www.cnblogs.com/dolphin0520/p/3920373.html  
1：将当前处理器的缓存行的内容写回到系统内存  
2：写回到内存的操作会使其他CPU里缓存了该内存地址的内容失效  
所以，如果大量使用volatile，会使CPU的缓存失效，且减少指令重排序，就会大大降低性能。
###jdk提供的原子类
atomic包

